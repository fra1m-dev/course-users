name: Sync todos.md to Issues

on:
  workflow_dispatch:
  push:
    branches: [main, master]

jobs:
  sync:
    runs-on: ubuntu-latest
    container: node:20-alpine   # запуск в докере
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install leasot
        run: npm i -D leasot

      - name: Build todos.md (TODO+FIXME)
        run: |
          npm run todos:md
          echo "---- todos.md (head) ----"
          sed -n '1,120p' todos.md || true

      - name: Create/Update issues from todos.md
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');

            // ensure labels
            async function ensureLabel(name, color, description) {
              try {
                await github.rest.issues.getLabel({ owner: context.repo.owner, repo: context.repo.repo, name });
              } catch {
                await github.rest.issues.createLabel({ owner: context.repo.owner, repo: context.repo.repo, name, color, description });
              }
            }

            // parse single leasot markdown file into two tables
            function splitSections(md) {
              const idx = md.indexOf('### FIXMEs');
              if (idx === -1) {
                return { todosBlock: md, fixmesBlock: '' };
              }
              return { todosBlock: md.slice(0, idx), fixmesBlock: md.slice(idx) };
            }

            function parseTable(mdBlock) {
              const rows = [];
              for (const line of mdBlock.split('\n')) {
                // | [src/file.ts](src/file.ts#L123) | 123 | текст |
                const m = line.match(/^\|\s*\[([^\]]+)\]\(([^)]+)\)\s*\|\s*(\d+)\s*\|\s*(.+?)\s*\|$/);
                if (m) rows.push({ file: m[1], link: m[2], lineNo: m[3], text: m[4] });
              }
              return rows;
            }

            async function findExisting(title) {
              const q = `repo:${context.repo.owner}/${context.repo.repo} is:issue in:title "${title}"`;
              const res = await github.rest.search.issuesAndPullRequests({ q, per_page: 10 });
              return res.data.items.find(i => i.title === title && i.state === 'open');
            }

            async function upsert(items, labelNames, kind) {
              for (const it of items) {
                const short = it.text.replace(/\s+/g, ' ').trim();
                const title = `[${kind}] ${it.file}:${it.lineNo} — ${short}`.slice(0, 250);
                const body = [
                  `**Type:** ${kind}`,
                  ``,
                  `- File: \`${it.file}\` (line ${it.lineNo})`,
                  `- Link: ${it.link.startsWith('http') ? it.link : `\`${it.link}\``}`,
                  ``,
                  `> Extracted automatically from \`todos.md\`.`,
                ].join('\n');

                const existing = await findExisting(title);
                if (existing) {
                  await github.rest.issues.update({
                    owner: context.repo.owner, repo: context.repo.repo,
                    issue_number: existing.number, body
                  });
                } else {
                  await github.rest.issues.create({
                    owner: context.repo.owner, repo: context.repo.repo,
                    title, body, labels: labelNames
                  });
                }
              }
            }

            // read and split
            const md = fs.existsSync('todos.md') ? fs.readFileSync('todos.md','utf8') : '';
            const { todosBlock, fixmesBlock } = splitSections(md);

            // parse tables
            const todos = parseTable(todosBlock);
            const fixmes = parseTable(fixmesBlock);

            // ensure labels exist
            await ensureLabel('todo', '0E8A16', 'Auto-created from TODOs');
            await ensureLabel('fix', 'D73A4A', 'Auto-created from FIXMEs');
            await ensureLabel('bug', 'B60205', 'Bug-like FIXMEs');

            // create/update issues
            await upsert(todos, ['todo'], 'todo');
            await upsert(fixmes, ['fix','bug'], 'fixme');
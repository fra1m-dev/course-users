name: ci

on:
  push:
    branches: [main]
    tags: ['v*.*.*'] # —Ä–µ–ª–∏–∑–Ω—ã–π –ø—Ä–æ–≥–æ–Ω –ø—Ä–∏ –ø—É—à–µ —Ç–µ–≥–∞ vX.Y.Z
  pull_request:

permissions:
  contents: write # —Å–æ–∑–¥–∞—Ç—å –≤–µ—Ç–∫—É release/* –∏ –ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å —Ä–µ–ª–∏–∑
  packages: read

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

env:
  IMAGE_REPO: ${{ secrets.DOCKERHUB_USERNAME }}/${{ github.event.repository.name }}
jobs:
  ci:
    name: Lint/Build/Test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          registry-url: 'https://npm.pkg.github.com'
          scope: '@fra1m-dev'
          cache: npm

      - run: npm ci
        env:
          NODE_AUTH_TOKEN: ${{ secrets.PACKAGE_SECRET }}

      - run: npm run lint --if-present
      - run: npm run build
      - run: npm test --if-present

  sync_todos:
    name: Create issues from todos.md
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      pull-requests: write
    needs: ci
    if: ${{ github.event_name == 'push' && !startsWith(github.ref, 'refs/tags/') }}
    steps:
      - uses: actions/checkout@v4

      # - name: Skip if todos.md not changed
      #   id: diff
      #   run: |
      #     if git diff --name-only HEAD^ HEAD | grep -q "^todos.md$"; then
      #       echo "changed=true" >> $GITHUB_OUTPUT
      #     else
      #       echo "changed=false" >> $GITHUB_OUTPUT
      #     fi

      - name: Create/Update issues from todos.md
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const crypto = require('crypto');
      
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
      
            // --- –≤—Ö–æ–¥–Ω–æ–π —Ñ–∞–π–ª
            if (!fs.existsSync('todos.md')) { core.info('todos.md not found. Skip'); return; }
            const md = fs.readFileSync('todos.md','utf8').trim();
            if (!md) { core.info('todos.md is empty. Skip'); return; }
      
            // --- —Å–µ–∫—Ü–∏–∏
            const idx = md.indexOf('### FIXMEs');
            const todosBlock = idx === -1 ? md : md.slice(0, idx);
            const fixmesBlock = idx === -1 ? '' : md.slice(idx);
      
            // --- –ø–∞—Ä—Å–µ—Ä —Ç–∞–±–ª–∏—Ü
            function parse(block){
              const rows=[];
              for (const line of block.split('\n')) {
                const m = line.match(/^\|\s*\[([^\]]+)\]\(([^)]+)\)\s*\|\s*(\d+)\s*\|\s*(.+?)\s*\|$/);
                if (m) rows.push({ file:m[1], link:m[2], line:m[3], text:m[4].trim().replace(/\s+/g,' ') });
              }
              return rows;
            }
            const todos = parse(todosBlock);
            const fixmes = parse(fixmesBlock);
      
            // --- –ª–µ–π–±–ª—ã (–º—è–≥–∫–æ)
            async function ensureLabel(name,color,desc){
              try { await github.rest.issues.getLabel({ owner, repo, name }); }
              catch {
                try { await github.rest.issues.createLabel({ owner, repo, name, color, description: desc }); }
                catch (err) { core.warning(`Label "${name}" not created: ${err.status} ${err.message}`); }
              }
            }
            await ensureLabel('todo', '0E8A16', 'Auto-created from TODOs');
            await ensureLabel('fix',  'D73A4A', 'Auto-created from FIXMEs');
            await ensureLabel('bug',  'B60205', 'Bug');
            await ensureLabel('type: task', '0366D6', 'Task type');
            await ensureLabel('type: bug',  'D93F0B', 'Bug type');
      
            // --- –æ—Ç–∫—Ä—ã—Ç—ã–π milestone (–ø–µ—Ä–≤—ã–π)
            let milestoneNumber = undefined;
            try {
              const { data: mls } = await github.rest.issues.listMilestones({ owner, repo, state: 'open', per_page: 1 });
              milestoneNumber = mls[0]?.number;
            } catch (e) { core.warning(`Milestone lookup failed: ${e.message}`); }
      
            // --- assignee = –∞–≤—Ç–æ—Ä –ø—É—à–∞, –µ—Å–ª–∏ –∫–æ–ª–ª–∞–±–æ—Ä–∞—Ç–æ—Ä
            const assignee = context.actor;
            let canAssign = true;
            try {
              await github.rest.repos.checkCollaborator({ owner, repo, username: assignee });
            } catch {
              canAssign = false;
            }
      
            // --- —Å—Ç–∞–±–∏–ª—å–Ω—ã–π –∫–ª—é—á –ø–æ –∑–∞–ø–∏—Å–∏
            const makeKey = (kind, it) =>
              crypto.createHash('sha1').update(`${kind}|${it.file}|${it.line}`).digest('hex');
      
            // --- –ø–æ–∏—Å–∫ issue –ø–æ –∫–ª—é—á—É –≤ body
            async function findByKey(key) {
              const q = `repo:${owner}/${repo} is:issue in:body "${key}"`;
              const res = await github.rest.search.issuesAndPullRequests({ q, per_page: 10 });
              return res.data.items.find(i => i.state === 'open');
            }
      
            // --- —Å—Å—ã–ª–∫–∏ –Ω–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –∫–æ–º–º–∏—Ç
            const repoBase = `https://github.com/${owner}/${repo}/blob/${context.sha}/`;
            const abs = (link)=> link.startsWith('http') ? link : `${repoBase}${link}`;
      
            // --- —Å–æ–∑–¥–∞—Ç—å/–æ–±–Ω–æ–≤–∏—Ç—å –ø–æ –∫–ª—é—á—É
            async function upsert(items, coreLabels, kind, typeLabel){
              for (const it of items) {
                const key = makeKey(kind, it);
                const title = `[${kind}] ${it.file}:${it.line} ‚Äî ${it.text}`.slice(0,250);
                const body = [
                  `**Type:** ${kind}`,
                  ``,
                  `- File: \`${it.file}\` (line ${it.line})`,
                  `- Link: ${abs(it.link)}`,
                  ``,
                  `> Extracted automatically from \`todos.md\`.`,
                  ``,
                  `<!-- todo-key:${key} -->` // üëà –Ω–µ–≤–∏–¥–∏–º—ã–π —è–∫–æ—Ä—å –¥–ª—è –∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏
                ].join('\n');
      
                const existing = await findByKey(key);
                const labels = [...new Set([...coreLabels, typeLabel])];
      
                if (existing) {
                  await github.rest.issues.update({
                    owner, repo, issue_number: existing.number,
                    title, body, labels, milestone: milestoneNumber
                  });
                } else {
                  await github.rest.issues.create({
                    owner, repo, title, body,
                    labels, milestone: milestoneNumber,
                    assignees: canAssign ? [assignee] : undefined
                  });
                }
              }
            }
      
            await upsert(todos, ['todo'], 'todo', 'type: task');
            await upsert(fixmes, ['fix','bug'], 'fixme', 'type: bug');

  docker:
    name: Build & Push Docker (only on tag)
    runs-on: ubuntu-latest
    needs: ci
    if: startsWith(github.ref, 'refs/tags/v')
    steps:
      - uses: actions/checkout@v4

      - name: Resolve version
        id: ver
        run: |
          echo "version=${GITHUB_REF_NAME}" >> $GITHUB_OUTPUT
          echo "ref_sha=$(git rev-list -n 1 ${GITHUB_REF_NAME})" >> $GITHUB_OUTPUT

      - uses: docker/setup-qemu-action@v3
      - uses: docker/setup-buildx-action@v3

      - uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build & Push
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            ${{ env.IMAGE_REPO }}:${{ steps.ver.outputs.version }}
            ${{ env.IMAGE_REPO }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Create release branch from tag
        uses: actions/github-script@v7
        with:
          script: |
            const tag = process.env.GITHUB_REF_NAME;    // v1.2.3
            const sha = "${{ steps.ver.outputs.ref_sha }}";
            const ref = `refs/heads/release/${tag}`;
            try {
              await github.rest.git.createRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref,
                sha
              });
              core.info(`Created ${ref} at ${sha}`);
            } catch (e) {
              if (e.status === 422) core.info(`Branch ${ref} already exists, skip`);
              else throw e;
            }

  gh_release:
    name: Publish GitHub Release (only on tag)
    runs-on: ubuntu-latest
    needs: [ci, docker]
    if: startsWith(github.ref, 'refs/tags/v')
    steps:
      - uses: actions/checkout@v4

      # –ê–≤—Ç–æ–≥–µ–Ω–µ—Ä–∞—Ü–∏—è release notes –ø–æ –∏—Å—Ç–æ—Ä–∏–∏ –∫–æ–º–º–∏—Ç–æ–≤/PR
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }} # vX.Y.Z
          name: ${{ github.ref_name }}
          draft: false
          prerelease: false
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
